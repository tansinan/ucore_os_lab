# Lab 2 实验报告

## 说明
`Lab2的非编程实验中进行了一些对于工具脚本的改动。这些改动均在文中说明，但没有提交。`

`编程实验在自己的机器上测试时make grade可以得到全部分数。如果助教测试时发生Bug，希望能够进行通知。`

`由于文本编辑器的自动格式化功能，某些文件的结尾多余换行或行尾空格可能被删除。有些删除可能发生在敏感区域（如正确性检查程序），但实际上这些更改并不试图扰乱任何测试机制。`

## 练习1
练习1中要求我们实现first-fit连续物理内存分配算法可以理解为将内存中的可用块视作一个链表，并记录其大小，当每一次申请内存时，系统依地址顺序扫描所有的内存块，只要发现某一个可用块的大小大于所请求的内存，就把这块内存分配出去，同时调整这个块的起始地址和可用空间。
具体实现细节上，主要是的问题包括一下几点：

1.关于链表区块数据结构free_area.free_list的使用，我的思路和答案有很大区别。答案的思路是free_list里包含了所有的页面，并且通过一些标志位来标记一个页面是不是可用区块的开头。每一次申请或者释放内存时，都会有大量的页面信息需要被更新。而我的思路是free_list里面只存储每个可用区块的开头页面就够了。由于不需要对大量页面的标记进行填充，我认为相比之下我的方法的实现效率更高。

2.内存区域申请时的处理：申请内存区域时的处理比较简单，只需要按地址搜索，直到发现可用且大小足够的内存块为止。如果没有大小足够的内存块，则内存申请失败。否则，除非这块内存大小刚刚合适，需要将分出去一部分空间后剩下的可用区块重新加入可用区块列表之中。

3.当内存区域释放时的处理：当需要释放内存区块时，处理相对要复杂一些，首先需要遍历可用区块以确定释放的区块存储的位置，找到之后将释放的块插入，之后分别向前和向后查找，遇到相邻的块就合并，直到不能合并为止。

改进点：在我的算法中，保持first-fit算法的情况下，申请内存时的遍历查找是不可避免的。为了能够避免在释放内存时同样发生遍历的情况，可以考虑用一个二叉搜索树来存储所有的节点，这样有可能在对数时间内就找到新的空闲区块应当在链表中存放的位置。从而提高性能。

## 练习2

练习2的实现思路我和答案的基本一致（事实上我做的时候因为没有想到可以申请新的物理页面来解决页目录项无效的问题还参考了答案），即首先读取虚地址的高位检索到页目录项，然后检查对应的页目录是否有效。若有效，则直接返回。若无效，则检查传入参数是否允许创建新的页目录———若允许，则为利用练习1的成果，为第二级的页表分配一个物理页面并初始化，同时将配置对应的页目录的地址和标志位。若不允许，则返回无效地址NULL。这个实验的主要难点实际上在于涉及了很多物理地址和逻辑地址间的相互转换。

在练习2中，所谓的pde_t和pte_t其实就是32bit无符号整数，用于存储x86架构下的页目录项和页表项（或者说是第一级页表项和第二级页表项）。其高位20位表示的是下一级页表（对于页目录项）或者对应物理页面（对于页表项）的物理地址（之所以只需要20位是因为页面是4K对齐的）。而低位中存储了很多标志位。具体来说有如下这些：

存在位：表明页面是否存在，uCore中与页面交换和非法访问判断有关。
访问位与修改位（Dirty bit）：表明页面是否被访问过或者修改过，由硬件实现，uCore中用于辅助软件的页面替换算法。
用户权限位：表明页面是否可以被用户态读写，uCore中用于实现进程隔离和内核数据保护。
读写权限位：表明页面是否可写还是只读，uCore中可以用于限制应用程序的行为。

还有一些uCore没有用到的特殊的标志位，例如：
页面大小标志位：仅存在在于PDE中，可以配置4MB的页面大小，需要所谓的PSE（Page Size Extension）功能启用。
写穿（Write Through）和禁止缓存（Cache Disabled）位，用于控制CPU缓存该页面时的行为。

在x86架构中，当发生page fault时，代码的正常执行被中断，像一般的异常一样，根据发生错误的是用户态/内核态代码，会产生一个异常栈，其中的错误码的低三位惠济路究竟发生了何种异常（用户态试图非法访问？页面不存在？还是读写权限异常？），同时CPU的CR2寄存器中会包括发生错误的线性地址。

uCore中，会将page fault交由内核的页面访问异常处理程序进行处理，程序会判断页错误的类型。如果是由于非法访问引发的错误，则引发页面错误的进程通常会被终止执行。而如果是合法的访问，但是页面却不存在的话，则有两种可能性：一是该页面尚未映射到对应的物理页面，此时uCore会将页面映射补全然后回复正常执行。另外一种情况则是该页面已经被交换到了外部存储器中。此时uCore会将页面交换回来然后回复正常执行。

## 练习3
page_remove_pte的任务相对简单，该函数首先需要确定传入的PTE项确实有效才能执行删除指令（否则页面的引用计数将会被错误地减少，导致仍被使用的屋里页面被释放）。

接下来，该函数将给定的页表项清零，并且找到对应的物理页面，减少其引用计数，如果其引用计数为0，则需要释放该物理页面。x86处理器并不会自动地更新页表的缓存——TLB，因此如果修改的页表项对应的页表当前正在被使用，需要使用invlpg指令强制CPU更新对应地址的页表项。

关于struct Page* pages这个全局变量，它是与物理页面有一一对应关系，和逻辑页面没有直接关系。事实上，该变量的内容是在pmm.c的page_init进行物理内存管理模块的初始化时，根据内存探测的结果初始化的，每个物理页面都由对应的一个Page结构体。由于一个物理页面可能不对应或者对应多个逻辑页面，因此该结构体有引用计数机制。页目录项和页表项和pages没有直接对应关系，但他们中如果存储了有效的映射到的物理页面，则对应的物理页面与pages中的项有对应关系。

在目前lab2的框架下，pmm的接口只能允许在分配内存时指定要分配的大小，但是不能指定要分配的地址，因此如果要实现的话，要么是给get_pte传参数保证页面对应的物理地址，要么是允许pmm的接口指定内存分配的位置（可是这样不就成了手动的物理内存管理了么= =），或者另一个可能更好的办法是直接建立一个新的页目录及其对应的页表，里面物理地址按逻辑地址填。
