# Lab 5 实验报告

## 说明
`编程实验在自己的机器上测试时make grade可以得到全部分数。如果助教测试时发生Bug，希望能够进行通知。`

`由于文本编辑器的自动格式化功能，某些文件的结尾多余换行或行尾空格可能被删除。有些删除可能发生在敏感区域（如正确性检查程序），但实际上这些更改并不试图扰乱任何测试机制。`

## 练习1
在lab5中，load_icode函数的实现非常容易，因为题目已经提供的代码已经实现了ELF格式的可执行文件的加载，我们只需要将trapframe中的段寄存器，堆栈寄存器，eip寄存器设置好，并且配置eflags确保进程切换后中断处于开启状态即可。而具体的ELF头部解析，为执行文件分配内存，ELF段加载等工作都无需我们处理。

## 练习2
copy_range的实现的意义在于将一个进程的地址空间内的数据复制到另一个进程。由于进程空间连续的逻辑地址不一定能够对应到内核地址空间的连续逻辑地址，因此进行复制时必须使用逐页复制的方式。具体来说，对于需要复制数据中的每一页，copy_range都会根据虚拟地址找到或者分配一个虚拟页面，这个虚拟页面必然对应一个物理页面，可以通过再将物理页面的地址转换到内核空间的虚拟地址，这样就可以直接进行复制操作了。

COW（Copy On Write，写时复制）是一种能够减少内存操作的复制，事实上真正的Linux系统的fork是使用COW技术的。个人推测，如果uCore想要实现COW的话，可能会有一下两点需要主要处理：

1.fork时的代码需要调整，copy_range压根就不需要真正的执行任何内存复制操作（不然就不是写时复制了），但与此同时，被“复制”的页表项的权限需要做出调整，即应当被设置成只读的页面，这样，用户进程一旦试图修改这些页面，将会引发页错误。

2.页错误的处理代码需要进行重大调整。“合法”的页错误除了内存未分配、数据位于交换分区之外，另外一种可能便是页面的由于COW机制处于共享状态。此时应当为其中一个进程分配新的物理页面，执行页面拷贝，并且恢复页面的写权限。

# 练习3
关于fork，exec(ve)，这两个系统调用，它们和新进程的创建是密切相关的。事实上新进程的创建（除了最开始的idle和init），都是通过fork产生的，fork出的两个进程用户空间地址内容是完全相同的，唯一的区别就在于一个进程fork的返回值（放在eax寄存器里）是0，另一个则是1。至于进程接下来要利用这个差异做什么就不一定了。不过其中很可能的一件事就是其中一个进程理解执行execve系统调用——这将导致其中进程的内存空间被回收，并重新装入指定的执行文件的内容。

wait（或waitpid）和exit主要是关于进程状态切换的。该函数将导致进程陷入PROC_ZOMBIE状态，并且其内存空间被回收。进程的退出将会唤醒另外一个进程，通常优先考虑该进程的父进程。do_wait将导致进程陷入PROC_SLEEPING状态，等待某个子进程（或者，用waitpid可以指定等待进程的pid），直到该进程进入PROC_ZOMBIE状态。wait系统调用真正的导致进入zombie状态的进程被彻底删除，其所有资源均被释放。

进程状态的切换关系如下问所属（字符画不方便，用文本描述）
alloc_proc创建进程，此时进程属于PROC_UNINIT（未初始化状态）
之后经过proc_init, wakeup_proc函数调用，进程进入PROC_RUNNABLE
由于调度机制，进程在自己的时间片内会经由proc_run使得进程真正运行
try_free_pages, do_wait, do_sleep函数可以是进程进入PROC_SLEEPING状态
而wakeup_proc唤醒进程使之回到PROC_RUNNABLE状态
最终do_exit使得进程进入僵尸状态PROC_ZOMBIE等待回收
