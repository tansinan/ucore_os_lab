# Lab 7 实验报告

## 说明
`编程实验在自己的机器上测试时make grade通常可以得到全部分数。由于在用户态进程I/O时可能发生进程切换，有时测试程序输出的字符串会有一些错误。如果助教测试时发生Bug，希望能够进行通知。`

`由于文本编辑器的自动格式化功能，某些文件的结尾多余换行或行尾空格可能被删除。有些删除可能发生在敏感区域（如正确性检查程序），但实际上这些更改并不试图扰乱任何测试机制。`

## 练习1
内核级信号量的实质是一个计数器和一个等待队列。计数器表示的就是信号量的值，大于0表示空闲，小于0表示资源被占用需要等待释放。信号量有两种操作P和V，分别对应uCore程序中的down和up。down操作的可以使得信号量的值减少，但如果信号量的值已经不大于0了，则down操作会使得进程陷入等待状态之中。反之，up操作可以使得信号量的值增加，但是如果信号量的值已经不大于0并且有进程正在处于等待队列之中，则进程会被立即唤醒。

关于用户态和内核态的信号量的具体实现机制及其区别，内核态的信号量实现可以直接调用up/down方法访问内核的资源，但对于用户态进程来说，这样的访问是不可能的。因此内核态线程down执行时，如果线程陷入等待，方法是线程的状态被置为waiting，然后重新触发进程调度。反之，对于用户态进程来说，进程必然需要通过执行系统调用来访问一个信号量，因此在down执行时应当是根据信号量是否有空闲决定系统调用是否立即返回到原来的线程。

## 练习2
条件变量的产生为的是解决在若干个进入互斥体的程序段需要等待其它程序段的结果的问题。在这种情况下，忙等待是不可取的，因为没有其他程序能够进入互斥体，将会引起死循环。因此条件变量的使用时要考虑到整个管程的互斥体对象的锁定和释放。

对于条件变量的cond_wait的实现，首先线程自己会进入休眠状态，接下来，为了使得等待的条件有可能再度成立，cond_wait需要唤醒其他进程。首先考虑有无因为曾经执行cond_signal唤醒了其它线程而自己陷入睡眠的线程，如果有则将其唤醒。否则的话，便唤醒一个因为管程互斥体对象而不能执行的线程，只有其他进程能够继续执行，cond_wait才有可能能够继续正常运行。

而关于cond_signal的实现也是要同时兼顾条件变量和管程互斥体。如果cond_signal发现没有进程正在等待条件变量，则会恢复执行，否则，会唤醒正在等待的进程，并且由于互斥体的限制，自己将会进入等待状态。

关于用户态条件变量和内核态条件变量的区别，主要差异的源头应当还是由于用户态的保护机制，一般不能允许程序直接访问内核态管程结构体，因此相关的函数操作必须通过系统调用完成，这造成了进程的等待和唤醒间具体的操作存在差异。
