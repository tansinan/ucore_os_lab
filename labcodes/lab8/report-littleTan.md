# Lab 8 实验报告

## 说明
`编程实验在自己的机器上测试时make grade通常可以得到全部分数。由于在用户态进程I/O时可能发生进程切换，有时测试程序输出的字符串会有一些错误。如果助教测试时发生Bug，希望能够进行通知。`

`由于文本编辑器的自动格式化功能，某些文件的结尾多余换行或行尾空格可能被删除。有些删除可能发生在敏感区域（如正确性检查程序），但实际上这些更改并不试图扰乱任何测试机制。`

## 练习1
sfs的I/O操作也是需要分区块进行的，在我们的实验代码中，主要处理的是开头和结尾地址没有对齐的问题。实验思路主要是通过sfs_bmap_load_nolock读取节点的值，再通过sfs_buf_op将数据都入到缓冲区之中。主要需要注意处理的是开头和结尾访问地址不对齐的情况，另外还有文件大小小于一个区块的特殊情况需要处理以避免bug。

关于pipe实现，我的设计是这样的，存在一类特殊的文件系统节点，它们的类型被标记为pipe，对于这类文件系统节点，再初次有程序对他们执行I/O操作时，内核为它们分配一个缓冲队列，程序的所有I/O操作会被重定向到这个缓冲队列之中。同时如果缓冲区写满，或者读取缓冲区时缓冲区为空，进程将陷入等待状态，直到关到另一端的进程读取或写入了数据。

## 练习2
不同于之前的实验，这次实验中load_icode的函数全部留空由我们填写。就其实现流程来看，和之前的版本区别并没有那么大，只不过之前的版本是直接读取内存中的elf映像，而现在的版本是需要通过文件系统的相关操作来读取elf的映像（也就是可执行文件）。读取的过程主要包括以下几个内容：首先，需要读取elf文件的头部并且进行基本的合法性检查。接下来，一次加载elf中的每个代码段，并且为它们分配内存，设置权限。然后还要配置好应用程序的运行栈。最后修改trapframe中的相关寄存器的值，以便以后的上下文切换能够顺利进行。

关于硬链接与符号链接的实现，我的理解是这样的，硬链接本质上是多个文件指向一个相同的inode，因此实现的关键在于维护好引用计数机制，在硬链接创建/删除时，inode中的引用计数要有相应的调整。引用计数为0表示文件所对应的存储器空间可以被回收。

至于符号链接，我倾向于认为它本质上就是一个文件，其内容是指向的另一个文件，其inode特殊的类型标识使得系统在遇到对这样的文件的I/O操作时，能够触发重定向的机制，找到其指向的文件。
