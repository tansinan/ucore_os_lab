# Lab 3 实验报告

## 说明
`Lab3的非编程实验中进行了一些对于工具脚本的改动。这些改动均在文中说明，但没有提交。`

`编程实验在自己的机器上测试时make grade可以得到全部分数。如果助教测试时发生Bug，希望能够进行通知。`

`由于文本编辑器的自动格式化功能，某些文件的结尾多余换行或行尾空格可能被删除。有些删除可能发生在敏感区域（如正确性检查程序），但实际上这些更改并不试图扰乱任何测试机制。`

## 练习1
LAB3练习1中代码所在的do_pgfault函数的主要用途在于处理页错误。发生页错误时的处理流程uCore本身的代码已经为我们写的相当清楚了——首先，uCore会根据error_code检查页错误的类型。如果发生页错误的原因并非当前页面合法只是出于某些原因尚未被映射到的物理内存，而是真正的非法访问，则不会分配新的物理页面,并返回错误代码。（在本实验中由于只有内核态代码，因此最终将会引发kernel panic）。对于合法访问引发的page fault，内核首先找到对应的vma（Virtual Memory Area，虚拟内存中的连续内存区块）对象，找到其对应的权限，并且在物理内存中为它分配一页，然后配置对应的页表项使其指向对应的物理页面并且权限正确。
注意到LAB3的练习1中只处理了页面不存在的情况，而没有处理页面处于磁盘上的交换区的情况，两者页表项内容的主要区别在于如果页面不存在，页表项将是全零的，否则不是。

关于uCore页面替换算法与页表项组成的关系，其中主要相关的应该就是访问位（Access）和修改位（Dirty，或称脏位）了，在uCore的页面替换算法中，可以通过访问这两个位来获取页面是否近期被访问过或者修改过，例如时钟页面替换算法就可以利用访问位来作为时钟位了。而如果这两个标志位硬件没有提供，则通过软件来处理几乎是不可能的。另外存在（Present）标志位对于系统决定页面是否有效，是否需要分配新的内存空间。页面的用户态/内核态标志位也很重要，因为有些关键的内核页面是不能被交换的。

uCore的缺页服务例程如果在执行过程中访问到内存再次出现了异常，则属于嵌套异常。硬件会产生一个类似于上一次页错误的异常栈，但这个异常可以肯定必然是由内核态引发的。有关页错误的标志位信息依然会被写入error_code之中，发生异常的线性地址依然存储于CR2寄存器。最后这个异常还是要由uCore的缺页服务例程来处理，如果是非法访问则触发kernel panic，否则分配页面或者执行页面交换。

## 练习2
LAB3的练习2的主要内容是实现FIFO页面替换算法。FIFO页面替换算法算是最简单的一种页面替换算法了——当然，它的效果也并不是非常的好。实现的主要思路便是构造一个链表对象，链表中每一项表示一个可以被替换的页面。每分配一个物理页面，就把这个页面加在链表的尾部，而每次发生页错误，系统查询需要被换走的页面时，页面会从链表的头部取出。每一种页面替换算法实际上都是要实现一系列的函数，并将这些函数的指针填充到swap_manager结构体的成员里，这也是用C语言实现类似虚基类和虚函数的一种编程思想。

LAB3练习2的另外一个内容便是完善LAB1的缺页异常处理程序——如果发生了页错误并且页错误的原因是页面目前位于外存的交换分区的话，则获取需要换入的页面，将其换入，并且更新对应的PTE，同时将页面标记为可交换。

我认为要想在目前的代码框架下实现改进(Enhanced or Extended?uCore文档中的翻译似乎不一致)的时钟替换算法，需要在执行替换时进行遍历操作，如果满足需要被换出的页的特征（即访问位和修改位都为0），则执行替换，否则按照改进时钟算法的规则，更新标志位。在改进时钟算法中，换入和换出不但考虑了页面是否被访问，还考虑了页面是否被修改，可以减少磁盘I/O开销。
